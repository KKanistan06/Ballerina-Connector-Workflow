// Copyright (c) 2026 WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/file;
import ballerina/io;
import ballerina/regex;
import ballerina/time;

# Extract SDK version from JAR path
# 
# + jarPath - Path to JAR file
# + return - Extracted version string or "unknown"
function extractSdkVersion(string jarPath) returns string {
    string[] pathParts = regex:split(jarPath, "/");
    string filename = pathParts[pathParts.length() - 1];

    // Remove .jar extension
    if filename.endsWith(".jar") {
        filename = filename.substring(0, filename.length() - 4);
    }

    // Look for version-like segments (numbers with dots)
    string[] parts = regex:split(filename, "-");
    foreach string part in parts.reverse() {
        if regex:matches(part, "^[0-9]+\\.[0-9]+.*") {
            return part;
        }
    }

    return "unknown";
}

# Main function that analyzes a Java SDK JAR file using JavaParser approach.
#
# + jarPath - Path to the JAR file
# + outputDir - Output directory for metadata and reports
# + config - Analyzer configuration
# + return - Analysis result or error
public function analyzeJavaSDK(string jarPath, string outputDir, AnalyzerConfig config)
        returns AnalysisResult|AnalyzerError {

    time:Utc startTime = time:utcNow();
    string[] warnings = [];

    // Step 1: Check if it's a Maven coordinate or local JAR
    boolean isMavenCoordinate = jarPath.includes(":") && !jarPath.includes("/") && !jarPath.includes("\\");
    
    if !isMavenCoordinate {
        // Validate local JAR file exists
        boolean jarExists = check file:test(jarPath, file:EXISTS);
        if !jarExists {
            return error AnalyzerError(string `JAR file not found: ${jarPath}`);
        }

        if !config.quietMode {
            io:println(string `JAR file found: ${jarPath}`);
        }
    } else {
        if !config.quietMode {
            io:println(string `Resolving Maven coordinate: ${jarPath}`);
        }
    }

    // Step 2: Create output directory if it doesn't exist
    boolean outputExists = check file:test(outputDir, file:EXISTS);
    if !outputExists {
        check file:createDir(outputDir, file:RECURSIVE);
        if !config.quietMode {
            io:println(string `Created output directory: ${outputDir}`);
        }
    }

    // Step 3: Extract and analyze classes using JavaParser
    if !config.quietMode {
        io:println("Step 1/7: Extracting and analyzing classes with JavaParser...");
    }

    ClassInfo[]|AnalyzerError analysisResult = analyzeJarWithJavaParserWrapper(jarPath);
    if analysisResult is AnalyzerError {
        return analysisResult;
    }
    ClassInfo[] rawClasses = analysisResult;

    if !config.quietMode {
        io:println(string `Found ${rawClasses.length()} classes to analyze`);
    }

    // Write the full list of extracted classes to a file for easier inspection.
    check writeClassList(outputDir, rawClasses);

    // Step 4: Filter relevant classes for client identification
    if !config.quietMode {
        io:println("Step 2/7: Filtering relevant classes...");
    }

    ClassInfo[] filteredClasses = [];
    foreach ClassInfo cls in rawClasses {
        if isRelevantClientClass(cls) {
            filteredClasses.push(cls);
        }
    }

    if !config.quietMode {
        io:println(string `Filtered to ${filteredClasses.length()} relevant client classes`);
    }

    if filteredClasses.length() == 0 {
        return error AnalyzerError("No relevant client classes found in the JAR");
    }

    // Write filtered class list so it's available for inspection in the output directory
    check writeFilteredClassList(outputDir, filteredClasses);

    // Step 5: Identify root client class using LLM with weighted scoring
    if !config.quietMode {
        io:println("Step 3/7: Identifying root client class with LLM...");
    }

    // Increase candidate shortlist to give the LLM more options for side-by-side comparison
    [ClassInfo, LLMClientScore][]|AnalyzerError clientResult = identifyClientClassWithLLM(filteredClasses, 20);
    if clientResult is AnalyzerError {
        return clientResult;
    }
    
    // Get top 5 candidates with scores
    [ClassInfo, LLMClientScore][] topCandidates = clientResult;
    
    if !config.quietMode && topCandidates.length() > 0 {
        io:println("\nTop 5 Client Candidates (with weighted scores):");
        foreach int i in 0 ..< topCandidates.length() {
            [ClassInfo, LLMClientScore] [cls, score] = topCandidates[i];
            io:println(string `  ${i + 1}. ${cls.simpleName} (Score: ${score.totalScore}/100)`);
            io:println(string `     Package: ${cls.packageName}`);
            io:println(string `     Methods: ${cls.methods.length()}`);
        }
        io:println();
    }
    
    // Select the top LLM-scored candidate as the root client (LLM-only decision)
    // We focus on sync clients. If there are tied scores, we will apply a heuristic to prefer sync clients.
    int syncIndex = -1;
    foreach int i in 0 ..< topCandidates.length() {
        ClassInfo c = <ClassInfo> topCandidates[i][0];
        string lname = c.simpleName.toLowerAscii();
        if !lname.includes("async") {
            syncIndex = i;
            break;
        }
    }

    decimal topScore = 0.0;
    [ClassInfo, LLMClientScore][] tied = [];
    if syncIndex != -1 {
        // Use the first sync candidate's score as the topScore to group tied sync candidates
        topScore = <decimal> topCandidates[syncIndex][1].totalScore;
        foreach var t in topCandidates {
            ClassInfo c = <ClassInfo> t[0];
            LLMClientScore s = <LLMClientScore> t[1];
            string lname = c.simpleName.toLowerAscii();
            if s.totalScore == topScore && !lname.includes("async") {
                tied.push([c, s]);
            } else if (s.totalScore < topScore) {
                break;
            }
        }
    } else {
        // No sync candidate found in the list; fall back to previous behavior using overall top score
        topScore = <decimal> topCandidates[0][1].totalScore;
        foreach var t in topCandidates {
            ClassInfo c = <ClassInfo> t[0];
            LLMClientScore s = <LLMClientScore> t[1];
            if s.totalScore == topScore {
                tied.push([c, s]);
            } else {
                break;
            }
        }
    }

    ClassInfo rootClient;
    if tied.length() == 1 {
        rootClient = tied[0][0];
    } else {
        // Choose the tied candidate with the largest number of methods
        int bestMethods = -1;
        ClassInfo? bestCls = null;
        foreach var t in tied {
            ClassInfo c = <ClassInfo> t[0];
            if c.methods.length() > bestMethods {
                bestMethods = c.methods.length();
                bestCls = c;
            }
        }
        if bestCls is ClassInfo {
            rootClient = bestCls;
        } else {
            rootClient = topCandidates[0][0];
        }
    }

    if !config.quietMode {
        io:println(string `Identified root client: ${rootClient.className}`);
    }

    // Step 6: Detect client initialization pattern (LLM-only)
    if !config.quietMode {
        io:println("Step 4/7: Detecting client initialization pattern...");
    }

    ClientInitPattern|AnalyzerError clientInitResult = detectClientInitPatternWithLLM(rootClient);
    if clientInitResult is AnalyzerError {
        return clientInitResult;
    }
    ClientInitPattern clientInitPattern = clientInitResult;

    // Step 7: Extract public methods from root client
    if !config.quietMode {
        io:println("Step 5/7: Extracting public methods...");
    }

    MethodInfo[] publicMethods = extractPublicMethods(rootClient);
    int totalMethods = publicMethods.length();

    if !config.quietMode {
        io:println(string `Found ${totalMethods} public methods`);
    }

    // Step 8: Rank methods by usage using LLM
    if !config.quietMode {
        io:println("Step 6/7: Ranking methods by usage with LLM...");
    }

    MethodInfo[]|AnalyzerError rankedResult = rankMethodsByUsageWithLLM(publicMethods);
    if rankedResult is AnalyzerError {
        return rankedResult;
    }
    MethodInfo[] selectedMethods = rankedResult;

    // Step 9: Generate structured metadata
    if !config.quietMode {
        io:println("Step 7/7: Generating structured metadata...");
    }

    StructuredSDKMetadata structuredMetadata = generateStructuredMetadata(
        rootClient,
        clientInitPattern,
        selectedMethods,
        filteredClasses
    );

    // Try to infer SDK version from the provided JAR path
    string sdkVersion = extractSdkVersion(jarPath);
    // Update the nested sdkInfo.version field (record is mutable here)
    structuredMetadata.sdkInfo.version = sdkVersion;

    // Step 10: Create final metadata object
    time:Utc endTime = time:utcNow();
    decimal duration = time:utcDiffSeconds(endTime, startTime);
    int durationMs = <int>(duration * 1000);

    // Step 11: Write outputs
    if !config.quietMode {
        io:println();
        io:println("Writing output files...");
    }

    // Write structured metadata JSON with SDK simple name
    string sdkSimpleName = structuredMetadata.rootClient.simpleName.toLowerAscii();
    string metadataPath = string `${outputDir}/${sdkSimpleName}-metadata.json`;
    check writeStructuredMetadata(structuredMetadata, outputDir, sdkSimpleName);

    if !config.quietMode {
        io:println(string `Structured metadata written to: ${metadataPath}`);
    }

    if !config.quietMode {
        string reportPath = string `${outputDir}/analysis-report.txt`;
        io:println(string `Analysis report written to: ${reportPath}`);
    }

    // Calculate final duration
    time:Utc finalEndTime = time:utcNow();
    decimal finalDuration = time:utcDiffSeconds(finalEndTime, startTime);

    if !config.quietMode {
        io:println(string `Analysis completed in ${finalDuration} seconds`);
    }

    return {
        success: true,
        metadataPath: metadataPath,
        classesAnalyzed: 1,
        methodsExtracted: totalMethods,
        durationMs: durationMs,
        warnings: warnings
    };
}

# Check if a class is relevant for client identification
#
# + cls - ClassInfo to evaluate
# + return - true if relevant, false otherwise
function isRelevantClientClass(ClassInfo cls) returns boolean {
    // Skip enums
    if cls.isEnum {
        return false;
    }

    // Skip abstract classes (but allow interfaces even if they are marked abstract)
    if cls.isAbstract && !cls.isInterface {
        return false;
    }

    // Skip inner classes and anonymous classes
    if cls.className.includes("$") {
        return false;
    }

    // Include classes with many public methods
    int publicMethodCount = 0;
    foreach MethodInfo method in cls.methods {
        if !method.isStatic && !method.isAbstract {
            publicMethodCount += 1;
        }
    }

    return publicMethodCount > 5;
}

# Wrapper function for JavaParser analysis
#
# + jarPath - Path to JAR file
# + return - Array of ClassInfo or error
public function analyzeJarWithJavaParserWrapper(string jarPath) returns ClassInfo[]|AnalyzerError {
    // Call into the jar parser which wraps the Java interop implementation.
    // This supports both local JAR paths and Maven coordinates.
    ClassInfo[]|error res = parseJarFromReference(jarPath);
    if res is error {
        // Convert generic error to AnalyzerError alias
        return <AnalyzerError> res;
    }
    return res;
}

# Write structured metadata to file - stub implementation
#
# + metadata - Structured metadata to write
# + outputDir - Output directory
# + sdkSimpleName - Simple name of the SDK for filename (default: "sdk")
# + return - Error if writing fails
function writeStructuredMetadata(StructuredSDKMetadata metadata, string outputDir, string sdkSimpleName = "sdk") returns error? {
    string path = string `${outputDir}/${sdkSimpleName}-metadata.json`;
    // Convert the typed record to a JSON value and write to file
    json j = metadata;
    // Pretty-print JSON to ensure valid, well-formatted output
    string content = prettyPrintJson(j, 0);
    // Ensure output directory exists (createDir is safe if already exists)
    boolean ok = check file:test(outputDir, file:EXISTS);
    if !ok {
        check file:createDir(outputDir, file:RECURSIVE);
    }
    check io:fileWriteString(path, content);
    return;
}

// Escape a string for inclusion in JSON
function escapeJsonString(string s) returns string {
    string out = "";
    int i = 0;
    while i < s.length() {
        string ch = s.substring(i, i + 1);
        if ch == "\\" {
            out += "\\\\";
        } else if ch == "\"" {
            out += "\\\"";
        } else if ch == "\n" {
            out += "\\n";
        } else if ch == "\r" {
            out += "\\r";
        } else if ch == "\t" {
            out += "\\t";
        } else {
            out += ch;
        }
        i += 1;
    }
    return out;
}

// Create indentation string (2 spaces per level)
function indentString(int level) returns string {
    int spaces = level * 2;
    string s = "";
    foreach int i in 0 ..< spaces {
        s += " ";
    }
    return s;
}

// Pretty-print JSON value recursively
function prettyPrintJson(json v, int indent) returns string {
    // Handle nil
    if v is () {
        return "null";
    }
    // Arrays
    if v is json[] {
        json[] arr = <json[]> v;
        if arr.length() == 0 {
            return "[]";
        }
        string out = "[\n";
        foreach int i in 0 ..< arr.length() {
            out += indentString(indent + 1) + prettyPrintJson(arr[i], indent + 1);
            if i < arr.length() - 1 {
                out += ",\n";
            } else {
                out += "\n";
            }
        }
        out += indentString(indent) + "]";
        return out;
    }

    // Objects (maps)
    if v is map<json> {
        map<json> m = <map<json>> v;
        string[] keys = m.keys();
        if keys.length() == 0 {
            return "{}";
        }
        string out = "{\n";
        foreach int i in 0 ..< keys.length() {
            string k = keys[i];
            json val = m[k];
            out += indentString(indent + 1) + "\"" + k + "\": " + prettyPrintJson(val, indent + 1);
            if i < keys.length() - 1 {
                out += ",\n";
            } else {
                out += "\n";
            }
        }
        out += indentString(indent) + "}";
        return out;
    }

    // Primitives
    if v is string {
        return "\"" + escapeJsonString(<string> v) + "\"";
    }
    if v is boolean {
        return v.toString();
    }
    if v is int {
        return v.toString();
    }
    if v is decimal {
        return v.toString();
    }

    // Fallback: use toString
    return v.toString();
}

# Write the list of all extracted classes to a text file for offline inspection
#
# + outputDir - Output directory to write the class list file
# + rawClasses - Array of ClassInfo representing all extracted classes from the JAR
# + return - Error if writing fails, otherwise nil
function writeClassList(string outputDir, ClassInfo[] rawClasses) returns error? {
    string path = string `${outputDir}/classes.txt`;
    string[] lines = [];
    foreach int i in 0 ..< rawClasses.length() {
        ClassInfo rc = rawClasses[i];
        lines.push(string `${i + 1}. ${rc.simpleName} - ${rc.packageName}`);
    }
    string content = string:'join("\n", ...lines);

    boolean ok = check file:test(outputDir, file:EXISTS);
    if !ok {
        check file:createDir(outputDir, file:RECURSIVE);
    }
    check io:fileWriteString(path, content);
    return;
}

# Write the list of filtered classes
#
# + outputDir - Output directory to write the class list file  
# + filteredClasses - Array of ClassInfo representing filtered classes
# + return - return value description
function writeFilteredClassList(string outputDir, ClassInfo[] filteredClasses) returns error? {
    string path = string `${outputDir}/filtered-classes.txt`;
    string[] lines = [];
    foreach int i in 0 ..< filteredClasses.length() {
        ClassInfo rc = filteredClasses[i];
        lines.push(string `${i + 1}. ${rc.simpleName} - ${rc.packageName} | methods: ${rc.methods.length()} | interface: ${rc.isInterface}`);
    }
    string content = string:'join("\n", ...lines);

    boolean ok = check file:test(outputDir, file:EXISTS);
    if !ok {
        check file:createDir(outputDir, file:RECURSIVE);
    }
    check io:fileWriteString(path, content);
    return;
}
